"""Chat API endpoints for mental health AI assistant."""

import logging
from typing import Annotated
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, status
from pydantic import BaseModel, Field

from app.api.dependencies import get_agent_orchestration_service, get_current_user
from app.core.domain.value_objects import AgentResponse, ChatContext
from app.core.models.auth import User
from app.infra.adapters import AgentOrchestrationService

router = APIRouter(prefix="/chat", tags=["chat"])
logger = logging.getLogger(__name__)


class ChatRequest(BaseModel):
    """Chat request model."""

    message: str = Field(..., min_length=1, max_length=10000, description="User message")
    conversation_id: UUID | None = Field(None, description="Optional conversation ID")
    history: list[str] = Field(
        default_factory=list, max_length=10, description="Recent conversation history"
    )


class ChatResponseModel(BaseModel):
    """Chat response model."""

    response: str = Field(..., description="AI assistant response")
    agent_name: str = Field(..., description="Name of agent that handled the request")
    conversation_id: UUID | None = Field(None, description="Conversation ID")
    processing_time_ms: int = Field(..., description="Processing time in milliseconds")
    metadata: dict[str, str] = Field(default_factory=dict, description="Additional metadata")


@router.post("/", response_model=ChatResponseModel)
async def send_message(
    request: ChatRequest,
    current_user: Annotated[User, Depends(get_current_user)],
    agent_service: Annotated[
        AgentOrchestrationService, Depends(get_agent_orchestration_service)
    ],
) -> ChatResponseModel:
    """Send a message to the AI assistant.

    This endpoint handles the complete flow:
    1. Receives user message
    2. Builds conversation context
    3. Routes to appropriate ADK agent
    4. Returns agent response

    Args:
        request: Chat request with message and optional history.
        current_user: Authenticated user.
        agent_service: Agent orchestration service.

    Returns:
        ChatResponseModel: AI assistant response.

    Raises:
        HTTPException: If processing fails.
    """
    try:
        logger.info(
            f"Chat request from user {current_user.id}: "
            f"message length={len(request.message)}, "
            f"history length={len(request.history)}"
        )

        # Build conversation context
        context = ChatContext(
            recent_messages=request.history[-10:],  # Keep last 10 messages
            sentiment=None,
            detected_topics=[],
            crisis_indicators=[],
            session_duration_minutes=0,
        )

        # Route message through ADK agents
        agent_response: AgentResponse = await agent_service.route_message(
            message=request.message, context=context, user_id=str(current_user.id)
        )

        logger.info(
            f"Response generated by {agent_response.agent_name} "
            f"in {agent_response.processing_time_ms}ms"
        )

        # Return response
        return ChatResponseModel(
            response=agent_response.content,
            agent_name=agent_response.agent_name,
            conversation_id=request.conversation_id,
            processing_time_ms=agent_response.processing_time_ms,
            metadata=agent_response.metadata,
        )

    except Exception as e:
        logger.error(f"Chat processing failed: {e}", exc_info=True)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to process message: {str(e)}",
        ) from e


@router.post("/stream", response_model=ChatResponseModel)
async def send_message_stream(
    request: ChatRequest,
    current_user: Annotated[User, Depends(get_current_user)],
    agent_service: Annotated[
        AgentOrchestrationService, Depends(get_agent_orchestration_service)
    ],
) -> ChatResponseModel:
    """Send a message with streaming response (future implementation).

    Args:
        request: Chat request.
        current_user: Authenticated user.
        agent_service: Agent orchestration service.

    Returns:
        ChatResponseModel: Response.

    Note:
        Streaming implementation to be added when ADK supports it.
    """
    # For now, use regular response
    return await send_message(request, current_user, agent_service)


class ConversationHistoryResponse(BaseModel):
    """Conversation history response."""

    conversation_id: UUID
    messages: list[dict[str, str]]
    total_messages: int


@router.get("/{conversation_id}/history", response_model=ConversationHistoryResponse)
async def get_conversation_history(
    conversation_id: UUID,
    current_user: Annotated[User, Depends(get_current_user)],
    skip: int = 0,
    limit: int = 50,
) -> ConversationHistoryResponse:
    """Get conversation history.

    Args:
        conversation_id: Conversation ID.
        current_user: Authenticated user.
        skip: Number of messages to skip.
        limit: Maximum messages to return.

    Returns:
        ConversationHistoryResponse: Conversation history.

    Note:
        This requires repository implementation to fetch from database.
        For now, returns empty response.
    """
    # TODO: Implement with ConversationUseCases when repositories are ready
    logger.warning("Conversation history not yet implemented - requires repository")

    return ConversationHistoryResponse(
        conversation_id=conversation_id, messages=[], total_messages=0
    )


class HealthCheckResponse(BaseModel):
    """Health check response."""

    status: str
    agent_available: bool
    services_available: dict[str, bool]


@router.get("/health", response_model=HealthCheckResponse)
async def chat_health_check(
    agent_service: Annotated[
        AgentOrchestrationService, Depends(get_agent_orchestration_service)
    ],
) -> HealthCheckResponse:
    """Check chat service health.

    Args:
        agent_service: Agent orchestration service.

    Returns:
        HealthCheckResponse: Health status.
    """
    return HealthCheckResponse(
        status="healthy",
        agent_available=agent_service._root_agent is not None,
        services_available={
            "agent_orchestration": True,
            "llm_service": True,
            "embedding_service": True,
        },
    )
